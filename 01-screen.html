<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>モニターPro - 01 公民館</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body.monitor-body {
            background-color: #333;
            color: #fff;
            font-family: "Helvetica Neue", Arial, "Hiragino Kaku Gothic ProN", "Hiragino Sans", Meiryo, sans-serif;
            min-height: 100vh;
            width: 100vw;
            overflow-y: auto;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: background 0.3s ease;
        }

        /* --- 背景色 --- */
        .bg-black { background: radial-gradient(circle at center, #666 0%, #333 100%); }
        .bg-red   { background: linear-gradient(135deg, #8a0000 0%, #3d0000 100%); }
        .bg-blue  { background: linear-gradient(135deg, #003399 0%, #001133 100%); }
        .bg-green { background: linear-gradient(135deg, #004d40 0%, #00251f 100%); }
        .bg-orange{ background: linear-gradient(135deg, #cc4400 0%, #662200 100%); }
        .bg-purple{ background: linear-gradient(135deg, #5500aa 0%, #220044 100%); }

        /* --- 準備モード（色はそのままで点滅） --- */
        @keyframes prep-blink {
            0% { opacity: 1; filter: brightness(100%); }
            50% { opacity: 0.6; filter: brightness(120%); }
            100% { opacity: 1; filter: brightness(100%); }
        }
        body.monitor-body.is-prep {
            animation: prep-blink 1.2s infinite ease-in-out;
            /* 枠線などはあえて消してシンプルに */
        }

        /* --- メインエリア --- */
        #monitor-container {
            text-align: center;
            width: 100%;
            padding: 80px 20px 20px;
            margin: auto;
            z-index: 10;
        }

        #lyrics-guide { 
            font-family: "Hiragino Mincho ProN", serif;
            font-size: 3.5vmin;
            color: rgba(255,255,255,0.7);
            margin-bottom: 2vh;
            min-height: 1.5em;
        }

        #action-label { 
            display: inline-block;
            font-size: 6vmin;
            font-weight: 900; 
            background: rgba(0,0,0,0.4);
            padding: 0.2em 1em;
            border-radius: 50px;
            border: 2px solid rgba(255,255,255,0.4);
            margin-bottom: 2vh;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        #name-label { 
            display: block;
            font-size: 14vmin;
            font-weight: 900; 
            line-height: 1.1; 
            white-space: pre-wrap; 
            text-shadow: 0px 5px 15px rgba(0,0,0,0.8);
            width: 100%;
            transition: all 0.3s;
        }
        #name-label.two-lines-mode { font-size: 10vmin !important; line-height: 1.2; }

        /* --- 警告バー (02同様に01にも搭載) --- */
        #next-alert {
            margin-top: 5vh;
            padding: 15px 30px;
            background: rgba(255,255,255,0.9);
            color: #000;
            font-weight: bold;
            font-size: 4vmin;
            border-radius: 10px;
            display: inline-block;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s;
        }
        body.monitor-body.warning-mode #next-alert {
            opacity: 1;
            transform: translateY(0);
        }

        /* --- UI --- */
        #header-controls {
            position: absolute; top: 10px; left: 10px; right: 10px;
            display: flex; justify-content: space-between; z-index: 100;
        }
        #back-to-index-btn, #fullscreen-btn {
            background: rgba(0,0,0,0.5); color: #fff; border: 1px solid #777;
            padding: 8px 12px; text-decoration: none; font-size: 14px; border-radius: 4px; cursor: pointer;
        }
        #controls {
            position: fixed; bottom: 20px; left: 0; width: 100%;
            display: flex; flex-direction: column; align-items: center; gap: 10px;
            z-index: 100; opacity: 0; transition: opacity 0.3s;
        }
        body:hover #controls { opacity: 1; }
        input[type=range] { width: 80%; max-width: 600px; accent-color: #fff; cursor: pointer; }
        .btn-row { display: flex; gap: 20px; }
        .ctrl-btn {
            background: rgba(255,255,255,0.2); border: 1px solid #fff; color: #fff;
            padding: 10px 20px; font-size: 16px; border-radius: 30px; cursor: pointer;
        }
        #start-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: flex; justify-content: center; align-items: center; z-index: 999;
        }
        .big-start-btn {
            border: 3px solid #fff; padding: 40px 60px; font-size: 3rem; font-weight: bold; color: #fff;
            border-radius: 10px; background: rgba(255,255,255,0.1);
        }
        #player-wrapper { position: fixed; top:0; left:0; width:1px; height:1px; opacity:0; pointer-events:none; z-index:-1; }
    </style>
</head>
<body class="monitor-body bg-black">

    <div id="header-controls">
        <a href="index.html" id="back-to-index-btn">← 戻る</a>
        <button id="fullscreen-btn" onclick="toggleFullScreen()">全画面</button>
    </div>

    <div id="start-overlay" onclick="startPerformance()">
        <div class="big-start-btn">Tap to Start</div>
    </div>

    <div id="monitor-container">
        <div id="lyrics-guide">Stand by...</div>
        <span id="action-label">READY</span>
        <br>
        <span id="name-label">...</span>
        <br>
        <div id="next-alert">NEXT: ???</div>
    </div>

    <div id="controls">
        <input type="range" id="seek-bar" value="0" step="1">
        <div class="btn-row">
            <button class="ctrl-btn" onclick="skip(-5)">-5s</button>
            <button class="ctrl-btn" id="play-pause-btn" onclick="togglePlay()">PAUSE</button>
            <button class="ctrl-btn" onclick="skip(5)">+5s</button>
        </div>
    </div>
    
    <div id="player-wrapper"><div id="player"></div></div>

    <script src="https://www.youtube.com/iframe_api"></script>
    <script src="data01.js"></script>

    <script>
        let player;
        const lyricsEl = document.getElementById('lyrics-guide');
        const actionEl = document.getElementById('action-label');
        const nameEl = document.getElementById('name-label');
        const nextAlertEl = document.getElementById('next-alert');
        const seekBar = document.getElementById('seek-bar');

        let dataSec = [];
        if (typeof performanceData !== 'undefined') {
            dataSec = performanceData.map(d => ({
                s: parseTime(d[0]), l: d[1], m: d[2]
            }));
        } else {
            alert("data01.js が読み込めません！");
            nameEl.innerText = "DATA ERROR";
        }

        function parseTime(timeStr) {
            if (!timeStr) return 0;
            const parts = timeStr.split(':');
            return parseInt(parts[0]) * 60 + parseInt(parts[1]);
        }

        // キーワードから色名（CSSクラス名）を返す関数
        function getColorFromText(text) {
            if (!text) return null;
            if (text.includes("大字")) return "bg-red";
            if (text.includes("絵") || text.includes("めくる") || text.includes("青")) return "bg-blue";
            if (text.includes("板") || text.includes("緑")) return "bg-green";
            if (text.includes("色") || text.includes("橙") || text.includes("スプレー")) return "bg-orange";
            if (text.includes("退場") || text.includes("紫")) return "bg-purple";
            if (text.includes("赤")) return "bg-red";
            return null;
        }

        function onYouTubeIframeAPIReady() {
            player = new YT.Player('player', {
                videoId: 'lN17WxlwdTY',
                playerVars: { 'autoplay': 0, 'controls': 0, 'rel': 0, 'playsinline': 1 },
                events: { 'onReady': onPlayerReady }
            });
        }

        function onPlayerReady() {
            seekBar.max = player.getDuration();
            setInterval(updateMonitor, 100);
            seekBar.addEventListener('input', () => { player.seekTo(seekBar.value); });
        }

        function startPerformance() {
            document.getElementById('start-overlay').style.display = 'none';
            if (player && player.playVideo) {
                player.playVideo();
                document.getElementById('play-pause-btn').innerText = "PAUSE";
            }
        }
        function togglePlay() {
            if (!player || !player.getPlayerState) return;
            const state = player.getPlayerState();
            const btn = document.getElementById('play-pause-btn');
            if (state === 1) { player.pauseVideo(); btn.innerText = "PLAY"; }
            else { player.playVideo(); btn.innerText = "PAUSE"; }
        }
        function skip(sec) { if (player) player.seekTo(player.getCurrentTime() + sec); }
        function toggleFullScreen() {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else document.exitFullscreen();
        }

        function updateMonitor() {
            if (!player || !player.getCurrentTime) return;
            const currentTime = player.getCurrentTime();
            if(document.activeElement !== seekBar) seekBar.value = currentTime;
            
            // --- 現在の表示処理 ---
            let currentIndex = -1;
            let currentLyrics = "";
            for (let i = 0; i < dataSec.length; i++) {
                if (currentTime >= dataSec[i].s) {
                    currentLyrics = dataSec[i].l;
                    if (dataSec[i].m && dataSec[i].m.trim() !== "") currentIndex = i;
                } else break;
            }

            lyricsEl.innerText = currentLyrics || "";
            
            let bgClass = "bg-black"; // デフォルト（グレー）
            let isPrep = false;

            if (currentIndex !== -1) {
                let memo = dataSec[currentIndex].m;
                
                // 1. 今の指示から色を探す
                let color = getColorFromText(memo);
                
                // 2. 準備判定
                if (memo.includes("準備")) {
                    isPrep = true;
                    // もし今の指示に色がなければ、未来を先読みして色を決める
                    if (!color) {
                        for (let j = currentIndex + 1; j < dataSec.length; j++) {
                            if (dataSec[j].m && dataSec[j].m.trim() !== "") {
                                let nextColor = getColorFromText(dataSec[j].m);
                                if (nextColor) {
                                    color = nextColor; // 未来の色を採用
                                    break;
                                }
                            }
                        }
                    }
                }
                
                if (color) bgClass = color;

                // テキスト表示処理
                let parts = memo.split(/[、]/);
                let action = parts[0] || "";
                let nameStr = (parts[1] || "").trim();
                let names = "";
                
                if (nameStr) {
                    let nameList = nameStr.split('・');
                    if (nameList.length >= 3) {
                        let half = Math.ceil(nameList.length / 2);
                        names = nameList.slice(0, half).join('・') + "\n" + nameList.slice(half).join('・');
                        nameEl.classList.add('two-lines-mode');
                    } else {
                        names = nameList.join('\n');
                        nameEl.classList.remove('two-lines-mode');
                    }
                }
                actionEl.innerText = action;
                nameEl.innerText = names;
            }

            // --- 次アクション予告 (警告バー) ---
            let nextIndex = -1;
            for (let i = 0; i < dataSec.length; i++) {
                if (dataSec[i].s > currentTime && dataSec[i].m && dataSec[i].m.trim() !== "") {
                    nextIndex = i;
                    break;
                }
            }
            let isWarning = false;
            if (nextIndex !== -1) {
                const nextItem = dataSec[nextIndex];
                const timeLeft = nextItem.s - currentTime;
                // 8秒前から表示
                if (timeLeft <= 8 && timeLeft > 0) {
                    isWarning = true;
                    let nextParts = nextItem.m.split(/[、]/);
                    nextAlertEl.innerText = `NEXT: ${nextParts[0]} (${timeLeft.toFixed(1)})`;
                }
            }

            if (isWarning) document.body.classList.add('warning-mode');
            else document.body.classList.remove('warning-mode');

            // クラス適用
            document.body.className = `monitor-body ${bgClass} ${isPrep ? 'is-prep' : ''} ${isWarning ? 'warning-mode' : ''}`;
        }
    </script>
</body>
</html>
